use std::collections::HashMap;

const SEPARATOR: [char; 2] = ['/', '\\'];

#[derive(Debug, PartialEq, Eq)]
pub struct HkeyPath {
    inner: String,
}

impl HkeyPath {
    pub fn new(path: impl AsRef<str>) -> Self {
        Self::join_impl(Vec::new(), path.as_ref())
    }

    pub fn classes_root() -> Self {
        Self::new("HKEY_CLASSES_ROOT")
    }

    pub fn current_user() -> Self {
        Self::new("HKEY_CURRENT_USER")
    }

    pub fn local_machine() -> Self {
        Self::new("HKET_LOCAL_MACHINE")
    }

    pub fn users() -> Self {
        Self::new("HKET_USERS")
    }

    pub fn dyn_data() -> Self {
        Self::new("HKET_DYN_DATA")
    }

    fn join_impl<'a>(mut vec: Vec<&'a str>, path: &'a str) -> Self {
        for segment in path.split(SEPARATOR) {
            let segment = segment.trim();
            if segment.is_empty() {
                continue;
            } else if segment == "." {
                continue;
            } else if segment == ".." {
                vec.pop();
            } else {
                vec.push(segment);
            }
        }

        Self {
            inner: vec.join("\\"),
        }
    }

    pub fn join(&self, path: impl AsRef<str>) -> Self {
        let path = path.as_ref();
        let mut vec = Vec::<&str>::new();

        for segment in self.inner.split(SEPARATOR) {
            vec.push(segment);
        }

        Self::join_impl(vec, path)
    }

    #[inline]
    pub fn as_str(&self) -> &str {
        self.as_ref()
    }
}

impl AsRef<str> for HkeyPath {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}

#[derive(Debug)]
pub struct Hkey {
    pub path: HkeyPath,
    pub content: HashMap<String, String>,
}

#[repr(transparent)]
#[derive(Debug)]
pub struct HkeyCollection(pub Vec<Hkey>);

impl HkeyCollection {
    pub fn to_string(&self) -> String {
        let mut vec = Vec::<&str>::new();

        vec.push("Windows Registry Editor Version 5.00\n\n");
        vec.push("; Generated by Wine Breeze\n\n");

        for item in &self.0 {
            if item.content.is_empty() {
                continue;
            }
            vec.push("[");
            vec.push(item.path.as_str());
            vec.push("]\n");

            for (key, value) in &item.content {
                vec.push("\"");
                vec.push(key);
                vec.push("\"=");
                vec.push(value);
            }
        }

        vec.concat()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn should_able_to_create_path() {
        let raw = "HKEY_CURRENT_USER\\Control Panel\\Colors";
        let path1 = HkeyPath::new("HKEY_CURRENT_USER\\Control Panel\\Colors");
        let path2 = HkeyPath::current_user().join("Control Panel\\Colors");
        let path3 = HkeyPath::current_user().join("Control Panel/Colors");
        let path4 = HkeyPath::current_user()
            .join("Control Panel")
            .join("./Colors");
        let path5 = path1.join("SomethingSomething").join("../../Colors");

        assert_eq!(path1.as_str(), raw);
        assert_eq!(path2.as_str(), raw);
        assert_eq!(path3.as_str(), raw);
        assert_eq!(path4.as_str(), raw);
        assert_eq!(path5.as_str(), raw);
    }
}
