use std::borrow::Cow;

const SEPARATOR: [char; 2] = ['/', '\\'];

#[repr(transparent)]
#[derive(Debug, PartialEq, Eq)]
pub struct HkeyPath {
    inner: String,
}

impl HkeyPath {
    pub fn new(path: impl AsRef<str>) -> Self {
        Self::join_impl(Vec::new(), path.as_ref())
    }

    pub fn classes_root() -> Self {
        Self::new("HKEY_CLASSES_ROOT")
    }

    pub fn current_user() -> Self {
        Self::new("HKEY_CURRENT_USER")
    }

    pub fn local_machine() -> Self {
        Self::new("HKET_LOCAL_MACHINE")
    }

    pub fn users() -> Self {
        Self::new("HKET_USERS")
    }

    pub fn dyn_data() -> Self {
        Self::new("HKET_DYN_DATA")
    }

    fn join_impl<'a>(mut vec: Vec<&'a str>, path: &'a str) -> Self {
        for segment in path.split(SEPARATOR) {
            let segment = segment.trim();
            if segment.is_empty() {
                continue;
            } else if segment == "." {
                continue;
            } else if segment == ".." {
                vec.pop();
            } else {
                vec.push(segment);
            }
        }

        Self {
            inner: vec.join("\\"),
        }
    }

    pub fn join(&self, path: impl AsRef<str>) -> Self {
        let path = path.as_ref();
        let mut vec = Vec::<&str>::new();

        for segment in self.inner.split(SEPARATOR) {
            vec.push(segment);
        }

        Self::join_impl(vec, path)
    }

    #[inline]
    pub fn as_str(&self) -> &str {
        self.as_ref()
    }
}

impl AsRef<str> for HkeyPath {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}

#[derive(Debug)]
pub enum HkeyData {
    Delete,
    String(String),
    Dword(u32),
}

impl HkeyData {
    pub fn to_string(&self) -> String {
        match self {
            HkeyData::Delete => "-".to_owned(),
            HkeyData::String(it) => format!("{it:?}"),
            HkeyData::Dword(it) => format!("dword:{it:08x}"),
        }
    }
}

impl From<String> for HkeyData {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}

impl From<u32> for HkeyData {
    fn from(value: u32) -> Self {
        Self::Dword(value)
    }
}

#[derive(Debug)]
pub struct Hkey {
    pub path: HkeyPath,
    pub content: Vec<(String, HkeyData)>,
}

impl Hkey {
    pub fn new(path: HkeyPath) -> Self {
        Self {
            path,
            content: Vec::with_capacity(128),
        }
    }

    pub fn insert(&mut self, name: String, data: HkeyData) {
        self.content.push((name, data));
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct HkeyCollection<'a, T>(pub T)
where
    T: Iterator<Item = &'a Hkey>;

impl<'a, T> HkeyCollection<'a, T>
where
    T: Iterator<Item = &'a Hkey>,
{
    pub fn to_string(&mut self) -> String {
        let mut vec = Vec::<Cow<str>>::new();

        vec.push(Cow::Borrowed("Windows Registry Editor Version 5.00\n\n"));
        vec.push(Cow::Borrowed("; Generated by Wine Breeze\n\n"));

        for item in &mut self.0 {
            if item.content.is_empty() {
                continue;
            }

            vec.push(Cow::Borrowed("\n["));
            vec.push(Cow::Borrowed(item.path.as_str()));
            vec.push(Cow::Borrowed("]\n"));

            for (key, value) in &item.content {
                vec.push(Cow::Owned(format!("{:?}", key)));
                vec.push(Cow::Borrowed("="));
                vec.push(Cow::Owned(value.to_string()));
                vec.push(Cow::Borrowed("\n"));
            }

            vec.push(Cow::Borrowed("\n"));
        }

        vec.concat()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn should_able_to_create_path() {
        let raw = "HKEY_CURRENT_USER\\Control Panel\\Colors";
        let path1 = HkeyPath::new("HKEY_CURRENT_USER\\Control Panel\\Colors");
        let path2 = HkeyPath::current_user().join("Control Panel\\Colors");
        let path3 = HkeyPath::current_user().join("Control Panel/Colors");
        let path4 = HkeyPath::current_user()
            .join("Control Panel")
            .join("./Colors");
        let path5 = path1.join("SomethingSomething").join("../../Colors");

        assert_eq!(path1.as_str(), raw);
        assert_eq!(path2.as_str(), raw);
        assert_eq!(path3.as_str(), raw);
        assert_eq!(path4.as_str(), raw);
        assert_eq!(path5.as_str(), raw);
    }
}
